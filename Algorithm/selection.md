# 선택문제

- 입력 : n개의 값과 k(1<=k<=n)값
- 출력 : k번째로 작은 입력 값
- 목표 : 비교횟수 최소화

- n-1번의 비교 -> 최댓값 찾기 가능 : 상한(upperbound)
- n-1번의 비교가 필수적인 경우 : 하한 (lowerbound)

* n-1의 비교시 상한 하한이 모두 solve!

### 선택문제 2

- 토너먼트식으로 k=n 최대값찾기 -> 둘씩 짝지어서 비교하여 승자를 선택 (홀수일 경우 부전승) -> 최댓값 n-1번

- k=1, n : 최대값, 최소값 찾기

  1. 최대값을 먼저 n-1번 비교를 통해 찾는다.
  2. 최대값을 제외하고 n-1개를 n-2번 비교를 통해 최소값을 찾는다.
  3. 최종 -> 2n-3번의 비교

- k=1, n : 최대값 최소값찾기 경우의 수 줄이기
  1. 최대값은 토너먼트식으로 추려낸다.
  2. 최소값은 **1라운드에서 패배한 원소들을 서로 비교하면 된다.** -> n/2 개중에 최소값을 찾는다 -> (n/2 - 1)번 비교 !
  3. 최종 -> 3n/2 - 2 번 비교 -> upperbound, 해당 횟수만큼 비교를 진행하면 반드시 최대,최소가 찾아진다. (lowerbound도 동일하다고 증명되어있음)

### 선택문제 3

- k = 1, 2중에 제일 작은값, 두번째로 작은값 찾기
- n-1번 비교 + n-2번 비교 => 2n-3번 비교 (단순비교이므로 더 줄일 수 있음)

- 최소값구하기 -> 토너먼트를 진행하는 동안, 두번째로 작은 값은 최소값을 만나기 전까지 토너먼트에서 승리한다.
- 두번째로 작은값 구하기 -> n-1번을 통해 최소값을 추려내기. + round수 - 1번 비교
  - n=8, round수 3번
  - n=9, round수 4번
  - ....n=16, round수 4번
  - n=17, round수 5번
  - ....n=33, round수 6번
  - log2(n)의 올림 수가 round 수
- 최종 -> n - log2(n) (의 올림) - 2 => 해당 횟수는 upperbound와 lowerbound가 일치된다고 증명되어있음.
